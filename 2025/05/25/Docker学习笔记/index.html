<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Docker学习笔记 | 李瑞康Blog</title><meta name="author" content="李瑞康"><meta name="copyright" content="李瑞康"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Docker学习笔记docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 linux 或 windows 机器上。他基于虚拟化技术为每个镜像创建独立的容器，相互之间不干扰，可以做到秒级启动程序。 笔记基于 Centos7 进行学习。 Docker安装和运行 根据官方文档走一遍安装流程  **1. **在安装之前，首先要保证系统中没有">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker学习笔记">
<meta property="og:url" content="http://example.com/2025/05/25/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="李瑞康Blog">
<meta property="og:description" content="Docker学习笔记docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 linux 或 windows 机器上。他基于虚拟化技术为每个镜像创建独立的容器，相互之间不干扰，可以做到秒级启动程序。 笔记基于 Centos7 进行学习。 Docker安装和运行 根据官方文档走一遍安装流程  **1. **在安装之前，首先要保证系统中没有">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-05-25T02:14:27.000Z">
<meta property="article:modified_time" content="2025-05-25T02:19:53.401Z">
<meta property="article:author" content="李瑞康">
<meta property="article:tag" content="个人博客、个人网站">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Docker学习笔记",
  "url": "http://example.com/2025/05/25/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
  "image": "http://example.com/img/butterfly-icon.png",
  "datePublished": "2025-05-25T02:14:27.000Z",
  "dateModified": "2025-05-25T02:19:53.401Z",
  "author": [
    {
      "@type": "Person",
      "name": "李瑞康",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/05/25/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Docker学习笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">李瑞康Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Docker学习笔记</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Docker学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-05-25T02:14:27.000Z" title="Created 2025-05-25 10:14:27">2025-05-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-05-25T02:19:53.401Z" title="Updated 2025-05-25 10:19:53">2025-05-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%87%AA%E7%A0%94/">自研</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Docker学习笔记"><a href="#Docker学习笔记" class="headerlink" title="Docker学习笔记"></a>Docker学习笔记</h1><p>docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 linux 或 windows 机器上。他基于虚拟化技术为每个镜像创建独立的容器，相互之间不干扰，可以做到秒级启动程序。</p>
<p>笔记基于 Centos7 进行学习。</p>
<h2 id="Docker安装和运行"><a href="#Docker安装和运行" class="headerlink" title="Docker安装和运行"></a>Docker安装和运行</h2><blockquote>
<p>根据官方文档走一遍安装流程</p>
</blockquote>
<p>**1. **在安装之前，首先要保证系统中没有相关残留导致安装失败，卸载&#x2F;清理依赖</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">    docker-client \</span><br><span class="line">    docker-client-latest \</span><br><span class="line">    docker-common \</span><br><span class="line">    docker-latest \</span><br><span class="line">    docker-latest-logrotate \</span><br><span class="line">    docker-logrotate \</span><br><span class="line">    docker-engine</span><br></pre></td></tr></table></figure>

<p>**2. **清理依赖结束后，就需要安装 docker 所需的依赖了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils</span><br></pre></td></tr></table></figure>

<p>**3. **依赖安装完成后需要下载 docker 程序，官方默认提供的是国外的下载地址，这里换用阿里云的比较快</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<p>**4. **下载地址更换完成后就可以进行下载了，稍等片刻后 docker 就会安装成功</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>



<blockquote>
<p>docker 运行</p>
</blockquote>
<p>到目前为止如果上面命令都没有出现问题的话，docker 就已经安装完成了，接下来我们来运行一下 docker</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动docker服务</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="comment"># 相对应的结束docker服务</span></span><br><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>

<p>如果执行之后什么反应也没有就证明运行成功了，我们来查看一下当前 docker 的版本信息，执行正常的话就会打印出一堆版本相关的信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>

<p>接下来我们来运行一个 <code>hello-world</code> 的镜像来看一下运行流程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<p>让我们详细查看一下运行的流程：</p>
<p><img src="/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/docker-01.jpg"></p>
<blockquote>
<p>配置阿里云镜像加速</p>
</blockquote>
<p>之前我们安装 docker 的时候使用的就是阿里云的镜像地址，下载速度相比于原地址快了不少，接下来我们想要让 docker 下载其他镜像包的时候也是用阿里镜像地址，过程如下：</p>
<ol>
<li>登陆&#x2F;注册 阿里云官方网站</li>
<li>点进控制台</li>
<li>打开左侧侧边栏找到 <code>容器镜像服务</code> 并点击</li>
<li>找到左侧最下面的 <code>镜像加速器</code></li>
<li>选择符合环境的代码执行即可：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每个人的地址都不一样，我这里的镜像加速地址为：</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://lvqfsd83.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure>



<h2 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h2><p>先来简单介绍一下 <code>镜像</code> 和 <code>容器</code> 之前的关系，镜像可以理解为一个模板，java 中的一个类，我们想使用 docker 安装一个 mysql 的话首先要将镜像下载到本地，然后通过镜像启动一个容器，一个镜像可以启动多个容器，就像 java 中一个类可以创建多个实例，容器与容器之前都是相互隔离的。</p>
<blockquote>
<p>docker 命令导图 ( 官方文档 )</p>
</blockquote>
<p><img src="/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/docker-03.jpg"></p>
<h3 id="常见帮助命令"><a href="#常见帮助命令" class="headerlink" title="常见帮助命令"></a>常见帮助命令</h3><p>docker 中的帮助命令，后面都会接触到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker version       <span class="comment"># 查看docker版本信息</span></span><br><span class="line">docker info          <span class="comment"># 查看docker详细信息</span></span><br><span class="line">docker *** --<span class="built_in">help</span>    <span class="comment"># 查看某个命令的帮助命令</span></span><br><span class="line">docker stats         <span class="comment"># 查看当前docker运行状态</span></span><br><span class="line">docker ** inspect    <span class="comment"># 查看元数据</span></span><br><span class="line">docker <span class="built_in">history</span> **    <span class="comment"># 查看镜像构建历史</span></span><br></pre></td></tr></table></figure>

<p><code>docker version</code> 是查看版本信息的，类似 <code>java -version</code>，就不细说了，<code>docker info</code> 命令执行后会出现如下结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@MiWiFi-R4AC-srv ~]# docker info</span><br><span class="line">Client:</span><br><span class="line"> Debug Mode: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Containers: 2  <span class="comment"># 当前容器有2个</span></span><br><span class="line">  Running: 0    <span class="comment"># 正在运行的有0个</span></span><br><span class="line">  Paused: 0     <span class="comment"># 暂停运行的有0个</span></span><br><span class="line">  Stopped: 2    <span class="comment"># 停止运行的有2个</span></span><br><span class="line"> Images: 1      <span class="comment"># 镜像有1个</span></span><br><span class="line"> ...... 省略一大堆</span><br></pre></td></tr></table></figure>

<p><code>dockers *** help</code> 则是当你某个命令不知道怎么用的时候可以查看一下帮助文档，后面会简单的介绍一下</p>
<h3 id="基本镜像命令"><a href="#基本镜像命令" class="headerlink" title="基本镜像命令"></a>基本镜像命令</h3><blockquote>
<p>images 查看所有镜像</p>
</blockquote>
<p><code>docker images</code> 命令的作用是查看镜像信息，他可以直接使用，同时也可以携带参数使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接使用会显示镜像信息</span></span><br><span class="line">[root@MiWiFi-R4AC-srv ~]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              bf756fb1ae65        7 months ago        13.3kB</span><br></pre></td></tr></table></figure>

<p>这里简单说一下显示的信息含义：</p>
<ul>
<li><code>REPOSITORY</code>：当前镜像名称</li>
<li><code>TAG</code>：当前镜像版本号，当下载镜像时未指定版本号时，默认就会下载 latest 最新版</li>
<li><code>IMAGE ID</code>：当前镜像的 ID</li>
<li><code>CREATED</code>：镜像下载的时间</li>
<li><code>SIZE</code>：镜像占用大小 ( 一个 hello-world 才占用了 13.3kb 而已 )</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 -a 命令代表显示所有的镜像信息，目前和直接使用差别不大</span></span><br><span class="line">[root@MiWiFi-R4AC-srv ~]# docker images -a</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              bf756fb1ae65        7 months ago        13.3kB</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 -q 命令代表仅显示镜像的ID，可以配合上一个一起使用: docker images -aq</span></span><br><span class="line">[root@MiWiFi-R4AC-srv ~]# docker images -q</span><br><span class="line">bf756fb1ae65</span><br></pre></td></tr></table></figure>

<p>images 的命令常用的只有这些，如果你有些命令参数忘记怎么用，或者想要查询一些新的命令参数，就可以使用上面提到的 <code>--help</code> 命令，他会遍历出几乎所有的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@MiWiFi-R4AC-srv ~]# docker images --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Usage:	docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line">List images</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a, --all             Show all images (default hides intermediate images)</span><br><span class="line">      --digests         Show digests</span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --format string   Pretty-<span class="built_in">print</span> images using a Go template</span><br><span class="line">      --no-trunc        Don<span class="string">&#x27;t truncate output</span></span><br><span class="line"><span class="string">  -q, --quiet           Only show numeric IDs</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>search 搜索 docker 仓库( docker hub )</p>
</blockquote>
<p><code>docker search</code> 的命令就是搜索 docker hub 也就是 docker 仓库中已存在的镜像信息，假设说我现在要下载 mysql 的镜像，就可以先通过 search 命令查询 docker 仓库是否包含 mysql 的镜像，不过还是建议在官网查看 docker 仓库</p>
<p>Docker 仓库地址：<code>https://hub.docker.com/</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@MiWiFi-R4AC-srv ~]# docker search mysql</span><br><span class="line">NAME                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">mysql                             MySQL is a widely used, open-source relation…   9854                [OK]                </span><br><span class="line">mariadb                           MariaDB is a community-developed fork of MyS…   3599                [OK]                </span><br><span class="line">mysql/mysql-server                Optimized MySQL Server Docker images. Create…   720                                     [OK]</span><br><span class="line">percona                           Percona Server is a fork of the MySQL relati…   502                 [OK]                </span><br><span class="line">.........</span><br></pre></td></tr></table></figure>



<blockquote>
<p>pull 下载镜像</p>
</blockquote>
<p><code>docker pull</code> 命令就是从 docker hup 中下载镜像到本地，现在咱们继续上面的思路来下载 mysql</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意这个命令默认下载的是仓库中最新版本的mysql</span></span><br><span class="line"><span class="comment"># 这里我们要安装5版本的，我们就手动指定版本安装一下</span></span><br><span class="line"><span class="comment"># docker pull mysql</span></span><br><span class="line"></span><br><span class="line">[root@MiWiFi-R4AC-srv ~]# docker pull mysql:5.7.31</span><br><span class="line">5.7.31: Pulling from library/mysql</span><br><span class="line">bf5952930446: Pull complete </span><br><span class="line">8254623a9871: Pull complete </span><br><span class="line">938e3e06dac4: Pull complete </span><br><span class="line">ea28ebf28884: Pull complete </span><br><span class="line">f3cef38785c2: Pull complete </span><br><span class="line">894f9792565a: Pull complete </span><br><span class="line">1d8a57523420: Pull complete </span><br><span class="line">5f09bf1d31c1: Pull complete </span><br><span class="line">1b6ff254abe7: Pull complete </span><br><span class="line">74310a0bf42d: Pull complete </span><br><span class="line">d398726627fd: Pull complete </span><br><span class="line">Digest: sha256:da58f943b94721d46e87d5de208dc07302a8b13e638cd1d24285d222376d6d84</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> mysql:5.7.31</span><br><span class="line">docker.io/library/mysql:5.7.31</span><br></pre></td></tr></table></figure>

<p>注意这里指定的版本必须是 docker 仓库中已存在的</p>
<p><img src="/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/docker-02.jpg"></p>
<blockquote>
<p>rmi 删除镜像</p>
</blockquote>
<p><code>docker rmi</code> 是删除某个镜像的命令，rm 在 Linux 中代表删除的意思，i 代表的就是 images，后面跟上目标镜像的 ID 可以进行删除操作，也可以同时删除多个</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们来删除一下方才下载的 mysql</span></span><br><span class="line">[root@MiWiFi-R4AC-srv ~]# docker rmi 718a6da099d8</span><br><span class="line">Untagged: mysql:5.7.31</span><br><span class="line">Untagged: mysql@sha256:da58f943b94721d46e87d5de208dc07302a8b13e638cd1d24285d222376d6d84</span><br><span class="line">Deleted: sha256:718a6da099d82183c064a964523c0deca80619cb033aadd15854771fe592a480</span><br><span class="line">Deleted: sha256:058d93ef2bfb943ba6a19d8b679c702be96e34337901da9e1a07ad62b772bf3d</span><br><span class="line">Deleted: sha256:7bca77783fcf15499a0386127dd7d5c679328a21b6566c8be861ba424ac13e49</span><br><span class="line">Deleted: sha256:183d05512fa88dfa8c17abb9b6f09a79922d9e9ee001a33ef34d1bc094bf8f9f</span><br><span class="line">Deleted: sha256:165805124136fdee738ed19021a522bb53de75c2ca9b6ca87076f51c27385fd7</span><br><span class="line">Deleted: sha256:904abdc2d0bea0edbb1a8171d1a1353fa6de22150a9c5d81358799a5b6c38c8d</span><br><span class="line">Deleted: sha256:d26f7649f78cf789267fbbca8aeb234932e230109c728632c6b9fbc60ca5591b</span><br><span class="line">Deleted: sha256:7fcf7796e23ea5b42eb3bbd5bec160ba5f5f47ecb239053762f9cf766c143942</span><br><span class="line">Deleted: sha256:826130797a5760bcd2bb19a6c6d92b5f4860bbffbfa954f5d3fc627904a76e9d</span><br><span class="line">Deleted: sha256:53e0181c63e41fb85bce681ec8aadfa323cd00f70509107f7001a1d0614e5adf</span><br><span class="line">Deleted: sha256:d6854b83e83d7eb48fb0ef778c58a8b839adb932dd036a085d94a7c2db98f890</span><br><span class="line">Deleted: sha256:d0f104dc0a1f9c744b65b23b3fd4d4d3236b4656e67f776fe13f8ad8423b955c</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 强制删除</span></span><br><span class="line">docker -f rmi</span><br><span class="line"><span class="comment"># 同时删除多个</span></span><br><span class="line">docker rmi *** *** ***</span><br><span class="line"><span class="comment"># 小技巧：巧用linux命令删除全部镜像--将所有镜像ID作为rmi的参数</span></span><br><span class="line">docker rmi $(docker images -aq)</span><br></pre></td></tr></table></figure>



<h3 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h3><p>镜像的命令我们学习的差不多了，接下来我们来学习一下基于镜像运行的 <strong>容器命令</strong>，首先我们需要下载一个镜像以便于后面的学习，这里就下载一个 centos 镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos:centos7</span><br></pre></td></tr></table></figure>



<h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><blockquote>
<p>run 运行容器</p>
</blockquote>
<p>镜像下载完成后，我们就基于这个镜像使用 <code>docker run</code> 命令启动第一个容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行centos的centos7版本</span></span><br><span class="line">[root@localhost bin]# docker run centos:centos7</span><br></pre></td></tr></table></figure>

<p>容器运行时的参数有很多，这里简单介绍一下日后都会用到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker run</span><br><span class="line">  --name  为容器指定一个名称</span><br><span class="line">  -d   后台运行容器，并返回容器ID</span><br><span class="line">  -it  进入交互模式，可以通过控制台操作</span><br><span class="line">  -p   小写-设置端口映射【主机端口:容器端口】</span><br><span class="line">  -P   大写字母P：随机指定端口</span><br><span class="line">  -i   以交互模式运行，通常与 -t 同时使用</span><br><span class="line">  -t   为容器重新分配一个伪输入终端，通常与 -i 同时使用</span><br><span class="line">  -e   通常用于对容器内的环境进行一些设置</span><br><span class="line">  -v   绑定一个卷</span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line">docker run \</span><br><span class="line">   --name mysql \</span><br><span class="line">   -p 3306:3306 \  <span class="comment"># 端口映射，【外部端口:容器内端口】</span></span><br><span class="line">   mysql</span><br></pre></td></tr></table></figure>



<blockquote>
<p>ps 查看容器</p>
</blockquote>
<p>启动完成之后我们通过 <code>docker ps</code> 来查看一下当前正在运行的所有容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]# docker ps</span><br><span class="line">CONTAINER ID      IMAGE      COMMAND      CREATED       STATUS       PORTS      NAMES</span><br></pre></td></tr></table></figure>

<p>这时发现了一个奇怪的现象：我们启动了一个 centos 的容器却没有查看到，现在我们用 <code>-a</code> 参数在查看一次：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS </span><br><span class="line">b405d31e169a        centos:centos7      <span class="string">&quot;/bin/bash&quot;</span>         3 minutes ago       Exited </span><br></pre></td></tr></table></figure>

<p>-a 可以查看到所有的容器，这个时候我们就可以看到这个 centos7 了，这里我们需要留意一个坑：<strong>当 docker 运行了一个容器但是没有任何工作的时候，docker 为了节省资源就会把这个容器停掉</strong></p>
<blockquote>
<p>停止，删除容器</p>
</blockquote>
<p>我们来看一下当前 docker 中的容器有哪些：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# docker ps -aq</span><br><span class="line">4aabb967a88b</span><br><span class="line">1ce360aeec9d</span><br><span class="line">718aa9fe4a40</span><br><span class="line">a189953b0140</span><br><span class="line">f72af19691d4</span><br><span class="line">b405d31e169a</span><br></pre></td></tr></table></figure>

<p>我们来通过 <code>rm</code> 删除一个容器，之前使用过 <code>rmi</code> 其中的 i 表示 image 镜像，那么 <code>rm</code> 代表的就是容器，我们来执行一下删除命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 移除目标容器</span></span><br><span class="line">[root@localhost /]# docker <span class="built_in">rm</span> 4aabb967a88b</span><br><span class="line">4aabb967a88b</span><br></pre></td></tr></table></figure>

<p>现在我们把这些容器全部删除：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询所有容器的ID</span></span><br><span class="line">[root@localhost /]# docker ps -aq</span><br><span class="line">1ce360aeec9d</span><br><span class="line">718aa9fe4a40</span><br><span class="line">a189953b0140</span><br><span class="line">f72af19691d4</span><br><span class="line">b405d31e169a</span><br><span class="line"><span class="comment"># 移除所有</span></span><br><span class="line">[root@localhost /]# docker <span class="built_in">rm</span> $(docker ps -aq)</span><br><span class="line">1ce360aeec9d</span><br><span class="line">718aa9fe4a40</span><br><span class="line">a189953b0140</span><br><span class="line">f72af19691d4</span><br><span class="line">b405d31e169a</span><br><span class="line"><span class="comment"># 再次查询，结果为空</span></span><br><span class="line">[root@localhost /]# docker ps -aq</span><br><span class="line">[root@localhost /]#</span><br></pre></td></tr></table></figure>



<h4 id="交互命令"><a href="#交互命令" class="headerlink" title="交互命令"></a>交互命令</h4><blockquote>
<p>启动并进入这个容器</p>
</blockquote>
<p>假设说现在我们要运行并进入 ( 交互模式 ) 这个容器，我们需要依靠 <code>-it</code> 参数进行交互模式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行centos使用-it参数通过bash进行交互模式</span></span><br><span class="line">[root@localhost /]# docker run -it centos:centos7 /bin/bash</span><br><span class="line"><span class="comment"># 当我们使用 run -it 命令进入到该容器内部的时候，可以发现左侧的root@已经变成了容器ID，证明我</span></span><br><span class="line"><span class="comment"># 们现在使用的命令窗口是容器内的容器窗口，也就意味着我们成功运行并进入到了容器的内部</span></span><br><span class="line">[root@718aa9fe4a40 /]# <span class="built_in">ls</span></span><br><span class="line">anaconda-post.log  bin  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line"><span class="comment"># 推出该容器也很简单，输入exit命令即可，可以额看到root@后面的名称已经恢复至本机了。</span></span><br><span class="line">[root@718aa9fe4a40 /]# <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">[root@localhost /]#</span><br></pre></td></tr></table></figure>

<p>当我们推出当前容器的时候，容器也就不执行任何工作了，会自动停止运行，这里我们可以用到 &#x3D;&#x3D;Ctrl + P + Q&#x3D;&#x3D; 快捷键可以实现不中断运行的情况下推出当前容器： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们重新打开一个容器：</span></span><br><span class="line">[root@localhost /]# docker run -it centos:centos7 /bin/bash</span><br><span class="line"><span class="comment"># 这里在进入容器之后使用了快捷键【Ctrl + p + q】</span></span><br><span class="line">[root@1ce360aeec9d /]# [root@localhost /]# </span><br><span class="line"><span class="comment"># 回到系统中之后可以看到centos还在运行中</span></span><br><span class="line">[root@localhost /]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS </span><br><span class="line">1ce360aeec9d        centos:centos7      <span class="string">&quot;/bin/bash&quot;</span>         16 seconds ago      Up 16 </span><br></pre></td></tr></table></figure>



<blockquote>
<p>进入已启动的容器</p>
</blockquote>
<p>刚刚我们通过 <code>run</code> 命令配合 <code>-it</code> 参数运行并进入了容器，可如果容器正处于运行中，我们要中途进入容器修改一些内容，这是可以使用 <code>exec</code> 命令配合 <code>-it</code> 参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以看到当我们使用 exec -it 命令后，root@后面又变成了当前容器的ID</span></span><br><span class="line">[root@localhost /]# docker <span class="built_in">exec</span> -it 1ce360aeec9d /bin/bash</span><br><span class="line">[root@1ce360aeec9d /]# </span><br></pre></td></tr></table></figure>

<p>然后我们推出当前容器，这是我们发现了，执行 exit 后容器还是处于运行当中，因为我们的 <code>exec</code> 命令是新建一个命令窗口来操作容器的，推出仅仅是推出当前命令窗口，不会对原有的命令窗口造成影响</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@1ce360aeec9d /]# <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">[root@localhost /]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS </span><br><span class="line">1ce360aeec9d        centos:centos7      <span class="string">&quot;/bin/bash&quot;</span>         19 minutes ago      Up 19 </span><br></pre></td></tr></table></figure>

<hr />

<p>如果想要操作之前的命令窗口的话，可以使用 <code>attach</code> 命令进行操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# docker attach 1ce360aeec9d</span><br><span class="line">[root@1ce360aeec9d /]# <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">[root@localhost /]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS</span><br></pre></td></tr></table></figure>

<p>这回我们就可以发现了，执行 exit 退出后我们就看不到正在运行中的容器了</p>
<h4 id="文件导出"><a href="#文件导出" class="headerlink" title="文件导出"></a>文件导出</h4><blockquote>
<p>复制容器中的文件到主机</p>
</blockquote>
<p>我们在运行容器的时候，有些情况下需要将虚拟机内的文件导出到系统中，这是可以使用 <code>cp</code> 命令进行操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行一个容器，在home目录下创建一个文件</span></span><br><span class="line">[root@localhost /]# docker run -it centos:centos7 /bin/bash</span><br><span class="line">[root@4aabb967a88b /]# <span class="built_in">cd</span> /home</span><br><span class="line"><span class="comment"># 这里用 vi 的命令创建了一个文件并且写了一些数据</span></span><br><span class="line">[root@4aabb967a88b home]# vi good.txt</span><br><span class="line">[root@4aabb967a88b home]# <span class="built_in">cat</span> good.txt</span><br><span class="line">centos container file</span><br><span class="line"><span class="comment"># 保持运行退出容器</span></span><br><span class="line">[root@4aabb967a88b home]# [root@localhost /]# </span><br><span class="line">[root@localhost /]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED        </span><br><span class="line">4aabb967a88b        centos:centos7      <span class="string">&quot;/bin/bash&quot;</span>         About a minute ago   Up </span><br></pre></td></tr></table></figure>

<p>好了，现在 centos7 的容器中已经有了一个文件了，我们现在要在系统中将容器中的文件拷贝出来：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拷贝4aabb967a88b容器中的/home/good.txt文件到系统中的/home目录下</span></span><br><span class="line">[root@localhost /]# docker <span class="built_in">cp</span> 4aabb967a88b:/home/good.txt /home</span><br><span class="line">[root@localhost /]# <span class="built_in">cd</span> /home</span><br><span class="line">[root@localhost home]# <span class="built_in">ls</span></span><br><span class="line">good.txt</span><br><span class="line">[root@localhost home]# <span class="built_in">cat</span> good.txt </span><br><span class="line">centos container file</span><br></pre></td></tr></table></figure>

<p>我们在系统中已经可以看到这个 good.txt 文件了，查看后内容也是相对应的。</p>
<h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><blockquote>
<p>logs查看容器运行日志</p>
</blockquote>
<p>我们在容器运行的时候，想要查看控制台相关的日志信息，这个时候就需要用到 <code>logs</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看容器运行日志，目标为4aabb967a88b，这些都是刚刚联系文件拷贝时产生的日志</span></span><br><span class="line">[root@localhost /]# docker logs 4aabb967a88b</span><br><span class="line">[root@4aabb967a88b /]# <span class="built_in">ls</span></span><br><span class="line">anaconda-post.log  bin  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">[root@4aabb967a88b /]# <span class="built_in">cd</span> /home</span><br><span class="line">[root@4aabb967a88b home]# <span class="built_in">ls</span></span><br><span class="line">[root@4aabb967a88b home]# vi good.txt</span><br><span class="line">[root@4aabb967a88b home]# <span class="built_in">cat</span> good.txt </span><br><span class="line">centos container file</span><br><span class="line">[root@localhost /]#</span><br></pre></td></tr></table></figure>

<p>logs 命令会把执行过的日志打印出来，如果加上 <code>-f</code> 的参数，那么就会不停止的显示实时日志</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 容器内的日志信息会实时显示在控制台上，相对的控制台也会被锁定</span></span><br><span class="line">[root@localhost /]# docker logs -f 4aabb967a88b</span><br><span class="line">[root@4aabb967a88b /]# <span class="built_in">ls</span></span><br><span class="line">anaconda-post.log  bin  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">[root@4aabb967a88b /]# <span class="built_in">cd</span> /home</span><br><span class="line">[root@4aabb967a88b home]# <span class="built_in">ls</span></span><br><span class="line">[root@4aabb967a88b home]# vi good.txt</span><br><span class="line">[root@4aabb967a88b home]# <span class="built_in">cat</span> good.txt </span><br><span class="line">centos container file</span><br></pre></td></tr></table></figure>

<p><code>-f</code> 参数用来显示实时日志，<code>-t</code> 用来显示带有时间戳的日志，二者可以分开使用也可以一起使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# docker logs -tf 4aabb967a88b</span><br><span class="line">2020-08-19T03:32:12.533972619Z [root@4aabb967a88b /]# <span class="built_in">ls</span></span><br><span class="line">2020-08-19T03:32:12.534040057Z anaconda-post.log  bin  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">2020-08-19T03:32:21.402580132Z [root@4aabb967a88b /]# <span class="built_in">cd</span> /home</span><br><span class="line">2020-08-19T03:32:22.260532852Z [root@4aabb967a88b home]# <span class="built_in">ls</span></span><br><span class="line">2020-08-19T03:32:36.625635389Z [root@4aabb967a88b home]# vi good.txt</span><br><span class="line">2020-08-19T03:32:56.779850263Z [root@4aabb967a88b home]# <span class="built_in">cat</span> good.txt </span><br><span class="line">2020-08-19T03:33:27.951569452Z centos container file</span><br></pre></td></tr></table></figure>



<blockquote>
<p>容器内部进程查看</p>
</blockquote>
<p>我们都知道在系统中有进程的概念，那么如何在原系统中查看容器内的进程信息？这里可以使用 top 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UID                 PID                 PPID                C                   STIME </span><br><span class="line">root                2812                2796                0                   11:32 </span><br></pre></td></tr></table></figure>



<blockquote>
<p>查看容器元数据</p>
</blockquote>
<p>元数据是指关于当前容器的所有信息，使用 <code>inspect</code> 命令可以查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# docker inspect $(docker ps -q)</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;4aabb967a88b0bb037c59ce5a9019b4720ff7a4a2c06829a6c62daf268a8abaf&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2020-08-19T03:32:08.561373043Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Path&quot;</span>: <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Args&quot;</span>: [],</span><br><span class="line">        <span class="string">&quot;State&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Status&quot;</span>: <span class="string">&quot;running&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Running&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&quot;Paused&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Restarting&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;OOMKilled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Dead&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;Pid&quot;</span>: 2812,</span><br><span class="line">            <span class="string">&quot;ExitCode&quot;</span>: 0,</span><br><span class="line">            <span class="string">&quot;Error&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;StartedAt&quot;</span>: <span class="string">&quot;2020-08-19T03:32:08.966995236Z&quot;</span>,</span><br><span class="line">            <span class="string">&quot;FinishedAt&quot;</span>: <span class="string">&quot;0001-01-01T00:00:00Z&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        .......</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="提交一个镜像"><a href="#提交一个镜像" class="headerlink" title="提交一个镜像"></a>提交一个镜像</h2><p>我们 pull 下载的 centos7 就是一个镜像，基于这个镜像我们可以 run 运行多个容器，那么我们可以基于一个容器进行自定义的修改，最后提交为一个自定义的镜像，这样一来就可以为以后的部署节省了很多的时间</p>
<p>我们先删除掉之前那些容器，重新运行一个 centos7 的容器，然后在他上面安装一个 JDK8 并配置环境变量，过程就省略了，接下来我们就为该容器提交一个镜像</p>
<blockquote>
<p>commit 提交镜像</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用方法简介</span></span><br><span class="line">docker commit 容器ID 镜像名称</span><br><span class="line">    -a  提交的镜像作者；</span><br><span class="line">    -c  使用Dockerfile指令来创建镜像；</span><br><span class="line">    -m  提交时的说明文字；</span><br><span class="line">    -p  在commit时，将容器暂停。</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 创建一个基于JDK8环境的docker镜像：</span></span><br><span class="line">[root@localhost ~]# docker commit -a hanzhe -m <span class="string">&quot;centos7 for jdk&quot;</span> b13234efc1ff zhe1</span><br><span class="line">73c158ed0a60</span><br><span class="line">[root@localhost ~]# docker images</span><br><span class="line">REPOSITORY      TAG               IMAGE ID            CREATED             SIZE</span><br><span class="line">zhe1            latest            73c158ed0a60        2 minutes ago       786MB</span><br><span class="line">centos          centos7           7e6257c9f8d8        9 days ago          203MB</span><br></pre></td></tr></table></figure>

<p>这样一来我们的容器就提交为了一个镜像，我们可以通过 run 命令来执行测试一下这个镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是一个初始就包含JDK8环境的镜像</span></span><br><span class="line">[root@localhost ~]# docker run -it -d zhe1 /bin/bash</span><br><span class="line">f65e7682e20b46edfff618308252ba92378f1f0171be7b2abae660a66f46cab4</span><br><span class="line">[root@localhost ~]# docker <span class="built_in">exec</span> -it f65e7682e20b46e /bin/bash</span><br><span class="line">[root@f65e7682e20b /]# javac</span><br><span class="line">Usage: javac &lt;options&gt; &lt;<span class="built_in">source</span> files&gt;</span><br><span class="line"><span class="built_in">where</span> possible options include:</span><br><span class="line">  -g                         Generate all debugging info</span><br><span class="line">  -g:none                    Generate no debugging info</span><br><span class="line">  -g:&#123;lines,vars,<span class="built_in">source</span>&#125;     Generate only some debugging info</span><br><span class="line">  -nowarn                    Generate no warnings</span><br><span class="line">  -verbose                   Output messages about what the compiler is doing</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">[root@f65e7682e20b /]# java</span><br><span class="line">Usage: java [-options] class [args...]</span><br><span class="line">           (to execute a class)</span><br><span class="line">   or  java [-options] -jar jarfile [args...]</span><br><span class="line">           (to execute a jar file)</span><br><span class="line"><span class="built_in">where</span> options include:</span><br><span class="line">    -d32	  use a 32-bit data model <span class="keyword">if</span> available</span><br><span class="line">    -d64	  use a 64-bit data model <span class="keyword">if</span> available</span><br><span class="line">    -server	  to <span class="keyword">select</span> the <span class="string">&quot;server&quot;</span> VM</span><br><span class="line">                  The default VM is server.</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>







<h2 id="Docker数据持久化"><a href="#Docker数据持久化" class="headerlink" title="Docker数据持久化"></a>Docker数据持久化</h2><p>在 docker 中运行环境是以容器为单位的，每个容器都是一个个独立的 linux 环境，如果我们通过 docker 安装了一个 mysql 进行使用，那么当这个容器被删除 ( <code>docker rm ** </code>) 的话，数据库里面的数据也就随之不见了，这样的情况太过危险，所以这里需要学习一项数据持久化的命令，将容器内的应用数据 ( 例如 mysql ) 在本地系统中保存一份，这样一来即使容器被删除了我们还可以在本地系统中找到对应的数据信息。</p>
<p>下载一个 mysql 的镜像用来练习使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker pull mysql:5.7.31</span><br><span class="line">5.7.31: Pulling from library/mysql</span><br><span class="line">bf5952930446: Pull complete </span><br><span class="line">8254623a9871: Pull complete </span><br><span class="line">938e3e06dac4: Pull complete </span><br><span class="line">ea28ebf28884: Pull complete </span><br><span class="line">f3cef38785c2: Pull complete </span><br><span class="line">894f9792565a: Pull complete </span><br><span class="line">1d8a57523420: Pull complete </span><br><span class="line">5f09bf1d31c1: Pull complete </span><br><span class="line">1b6ff254abe7: Pull complete </span><br><span class="line">74310a0bf42d: Pull complete </span><br><span class="line">d398726627fd: Pull complete </span><br><span class="line">Digest: sha256:da58f943b94721d46e87d5de208dc07302a8b13e638cd1d24285d222376d6d84</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> mysql:5.7.31</span><br><span class="line">docker.io/library/mysql:5.7.31</span><br></pre></td></tr></table></figure>



<h3 id="数据卷挂载"><a href="#数据卷挂载" class="headerlink" title="数据卷挂载"></a>数据卷挂载</h3><p>我们要运行一个 mysql 容器进行数据卷挂载，但是 mysql 的密码我们不知道怎么设置，我们打开 看 hub 官网找到 mysql，docker hub 对每个镜像的使用都提供了帮助文档：</p>
<p><img src="/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/docker-04.jpg"></p>
<p>可以看到密码的设置通过 -e 设置就可以了，接下来我们就可以运行 mysql 了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">     --name mysql-1 \</span><br><span class="line">     -p 3000:3306 \</span><br><span class="line">     -v /home/mysql/config:/etc/mysql/conf.d \</span><br><span class="line">     -v /home/mysql/data:/var/lib/mysql \</span><br><span class="line">     -e MYSQL_ROOT_PASSWORD=zhang \</span><br><span class="line">     mysql:5.7.31</span><br></pre></td></tr></table></figure>

<p>这里使用的 <code>-v</code> 参数就是数据卷挂载，表现形式为：<code>-v 主机地址:容器地址</code>，他的作用是将主机中的某个目录挂载到容器中的目标目录，然后在容器中在操作目标目录进行读写操作的时候，实际上操作的就是主机的文件了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 映射目录的文件</span></span><br><span class="line">[root@localhost data]# <span class="built_in">ls</span></span><br><span class="line">auto.cnf    ca.pem           client-key.pem  ibdata1      ib_logfile1  mysql               private_key.pem  server-cert.pem  sys</span><br><span class="line">ca-key.pem  client-cert.pem  ib_buffer_pool  ib_logfile0  ibtmp1       performance_schema  public_key.pem   server-key.pem</span><br><span class="line"><span class="comment"># 通过SQLYog远程连接创建数据库之后创建了一个test库，然后这边在查看一下文件列表，发现多了test</span></span><br><span class="line">[root@localhost data]# <span class="built_in">ls</span></span><br><span class="line">auto.cnf    ca.pem           client-key.pem  ibdata1      ib_logfile1  mysql               private_key.pem  server-cert.pem  sys</span><br><span class="line">ca-key.pem  client-cert.pem  ib_buffer_pool  ib_logfile0  ibtmp1       performance_schema  public_key.pem   server-key.pem   <span class="built_in">test</span></span><br><span class="line">[root@localhost data]#</span><br></pre></td></tr></table></figure>

<p>这里需要注意点是，挂载的主机目录最好是一个不存在的目录 ( docker 会为你创建目录 ) 或者是空目录，不然的话本地的目录会将容器内的目录替换掉，容器内的源文件就会受到影响</p>
<h3 id="Volume挂载"><a href="#Volume挂载" class="headerlink" title="Volume挂载"></a>Volume挂载</h3><p>除了使用卷挂载之外，我们还可以使用 Volume 进行挂载，Volume 挂载指的就是 docker 在本机中提供了一个目录专门用来映射目标容器内的文件夹，我们可以用它来实现挂载，用法也很简单，和卷挂载非常的像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># volume挂载和卷挂载的区别就是，volume不需要指定主机的目录，docker会为你提供一个目录</span></span><br><span class="line">docker run -d \</span><br><span class="line">     --name mysql-2 \</span><br><span class="line">     -p 3001:3306 \</span><br><span class="line">     -v /etc/mysql/conf.d \</span><br><span class="line">     -v /var/lib/mysql \</span><br><span class="line">     -e MYSQL_ROOT_PASSWORD=zhang \</span><br><span class="line">     mysql:5.7.31</span><br></pre></td></tr></table></figure>

<p>这样一来我们就启动了一个 Volume 挂载的容器，这种挂载又被称为&#x3D;&#x3D;匿名挂载&#x3D;&#x3D;，我们现在来使用一个&#x3D;&#x3D;具名挂载&#x3D;&#x3D;：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">     --name mysql-3 \</span><br><span class="line">     -p 3002:3306 \</span><br><span class="line">     -v mysql3-config:/etc/mysql/conf.d \</span><br><span class="line">     -v mysql3-data:/var/lib/mysql \</span><br><span class="line">     -e MYSQL_ROOT_PASSWORD=zhang \</span><br><span class="line">     mysql:5.7.31</span><br></pre></td></tr></table></figure>

<p>在目录前面加上一个名字即可，注意不要使用 &#x2F; 开头，不然会被当成卷挂载，接下来让我来查看一下挂载对应本地的目录位置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost data]# docker volume <span class="built_in">ls</span></span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line"><span class="comment"># 像是这种就是匿名挂载，名称是随机生成的，找起来非常的麻烦</span></span><br><span class="line"><span class="built_in">local</span>               3f56a1c686886a93b6d46aef13f66046bf9934e41ecdfce0f017be224c5ff128</span><br><span class="line"><span class="built_in">local</span>               6fb883d330302fb20a783739abb80bf14a4a69a3ca73260880a81d83bd63d994</span><br><span class="line"><span class="built_in">local</span>               78c00ad8d5f31df1dc6c943f99110525f2b202ba697cefa7266e328fc7d64863</span><br><span class="line"><span class="built_in">local</span>               cdec4b03ffcfcebeeba319dcbc18116f5a6140bf94e71a27697fe78a35f23331</span><br><span class="line"><span class="built_in">local</span>               d8ffc79ee3f8d64e7f7c37e95ef759f5889434254d6d323fb671de9c37b35682</span><br><span class="line"><span class="built_in">local</span>               ec857e5eacb7eca3b73e6d6e38546fef06e95a856234fa5df17ef9c901a3bc1d</span><br><span class="line"><span class="built_in">local</span>               ee73c200f57bc189d5bf99657226f7164724ffa97cf2d240050f98354e36bf97</span><br><span class="line"><span class="comment"># 这种起了名字的就是具名挂载，识别性较高</span></span><br><span class="line"><span class="built_in">local</span>               mysql3-config</span><br><span class="line"><span class="built_in">local</span>               mysql3-data</span><br><span class="line"><span class="comment"># 查看存储目标位置</span></span><br><span class="line">[root@localhost data]# docker volume inspect mysql3-data</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2020-08-20T15:55:24+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: null,</span><br><span class="line">        <span class="comment"># 对应的目录在这个位置</span></span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/mysql3-data/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;mysql3-data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: null,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>校验位置是否正确：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 移动到目标目录查看文件</span></span><br><span class="line">[root@localhost data]# <span class="built_in">cd</span> /var/lib/docker/volumes/mysql3-data/_data</span><br><span class="line">[root@localhost _data]# <span class="built_in">ls</span></span><br><span class="line">auto.cnf    ca.pem           client-key.pem  ibdata1      ib_logfile1  mysql               private_key.pem  server-cert.pem  sys</span><br><span class="line">ca-key.pem  client-cert.pem  ib_buffer_pool  ib_logfile0  ibtmp1       performance_schema  public_key.pem   server-key.pem</span><br><span class="line"><span class="comment"># 新建了一个test3数据库后再来查看，发现多了对应的文件，目录正确</span></span><br><span class="line">[root@localhost _data]# <span class="built_in">ls</span></span><br><span class="line">auto.cnf    ca.pem           client-key.pem  ibdata1      ib_logfile1  mysql               private_key.pem  server-cert.pem  sys</span><br><span class="line">ca-key.pem  client-cert.pem  ib_buffer_pool  ib_logfile0  ibtmp1       performance_schema  public_key.pem   server-key.pem   test3</span><br></pre></td></tr></table></figure>

<p>匿名挂载可以通过查看元数据找到目录挂载位置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# docker inspect 1e602fbc5ec8</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">    	......</span><br><span class="line">        <span class="string">&quot;Mounts&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;volume&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;ec857e5eacb7eca3b73e6d6e38546fef06e95a856234fa5df17ef9c901a3bc1d&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Source&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/ec857e5eacb7eca3b73e6d6e38546fef06e95a856234fa5df17ef9c901a3bc1d/_data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Destination&quot;</span>: <span class="string">&quot;/etc/mysql/conf.d&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Mode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;RW&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;Propagation&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;volume&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;cdec4b03ffcfcebeeba319dcbc18116f5a6140bf94e71a27697fe78a35f23331&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Source&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/cdec4b03ffcfcebeeba319dcbc18116f5a6140bf94e71a27697fe78a35f23331/_data&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Destination&quot;</span>: <span class="string">&quot;/var/lib/mysql&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Mode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;RW&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;Propagation&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<blockquote>
<p>扩展知识</p>
</blockquote>
<p>当我们再看网上的命令的时候可能会看到对应的挂载结尾有一个 <code>:ro</code> 或者 <code>:rw</code>，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d:ro ...</span><br><span class="line">docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d:rw ...</span><br></pre></td></tr></table></figure>

<p>这代表的是挂载的读写权限，ro：readonly只读，rw：readwriter读写，如果开启了只读权限的话容器内就不能对目录进行写入操作了，写入操作完全在宿主机中完成。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">李瑞康</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2025/05/25/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">http://example.com/2025/05/25/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/05/25/java/" title="java"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">java</div></div><div class="info-2"><div class="info-item-1">JAVA 后端环境搭建 使用Git进行版本控制  SSMSSM 是一个在 Java Web 开发中非常流行的框架组合，全称为 Spring + SpringMVC + MyBatis。它结合了三个框架的优势，形成了一个高效、灵活且易于维护的开发框架，适用于构建企业级应用系统。 组成部分 Spring：一个开源的 Java 框架，提供依赖注入（IoC）和面向切面编程（AOP）功能，用于管理应用程序的对象和依赖关系，简化开发过程。 SpringMVC：基于 Spring 的 MVC 框架，用于处理 Web 请求和响应，实现请求的转发和视图管理。 MyBatis：一个持久层框架，提供对象关系映射（ORM），将数据库表的数据映射为 Java 对象，简化数据库操作。  分层结构SSM 框架遵循标准的 MVC 分层结构，分为四层：  DAO 层（Mapper 层）：负责数据的持久化操作，如增删改查等。 Service 层：封装业务逻辑，处理业务规则。 Controller 层：处理用户的请求，调用 Service 层的方法。 View...</div></div></div></a><a class="pagination-related" href="/2025/05/25/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Redis学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Redis学习笔记</div></div><div class="info-2"><div class="info-item-1">Redis 笔记redis 是一款 NoSQL 数据库，是最常见的一款非关系型数据库，主要使用 key - value 的形式存储数据，和 mysql 不同，redis 并不会直接把数据存储到硬盘中，而是存储在内存中，也正是这样的设定让 redis 的存取操作特别的快。 Redis 的下载及安装 redis 的下载  首先要去 redis 的官网下载他的压缩包，官网 [ 中文 ] 直连地址如下： 1http://www.redis.cn/  进入官网后直接下载即可，然后远程连接 服务器&#x2F;虚拟机 将下载好的文件上传至 /usr/local 目录下 1234# 进入到usr/local目录cd /usr/local# 上传文件后，执行解压命令tar -zxvf redis-5.0.5.tar.gz   redis 的安装  在执行安装命令之前，首选需要安装 gcc 的依赖，如已安装请忽略 1yum -y install gcc  然后切换到 redis 目录下开始执行安装命令 1234# 切换目录到redis下cd redis-5.0.5# 执行安装命令make...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">李瑞康</div><div class="author-info-description">一起努力</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">Docker学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E5%AE%89%E8%A3%85%E5%92%8C%E8%BF%90%E8%A1%8C"><span class="toc-number">1.1.</span> <span class="toc-text">Docker安装和运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.</span> <span class="toc-text">Docker常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.1.</span> <span class="toc-text">常见帮助命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.2.</span> <span class="toc-text">基本镜像命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.3.</span> <span class="toc-text">容器相关命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">基本命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">交互命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">文件导出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">其他命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E9%95%9C%E5%83%8F"><span class="toc-number">1.3.</span> <span class="toc-text">提交一个镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.4.</span> <span class="toc-text">Docker数据持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%8C%82%E8%BD%BD"><span class="toc-number">1.4.1.</span> <span class="toc-text">数据卷挂载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Volume%E6%8C%82%E8%BD%BD"><span class="toc-number">1.4.2.</span> <span class="toc-text">Volume挂载</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/25/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="RabbitMQ学习笔记">RabbitMQ学习笔记</a><time datetime="2025-05-25T02:16:31.000Z" title="Created 2025-05-25 10:16:31">2025-05-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/25/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Mybatis学习笔记">Mybatis学习笔记</a><time datetime="2025-05-25T02:16:02.000Z" title="Created 2025-05-25 10:16:02">2025-05-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/25/SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="SpringMVC学习笔记">SpringMVC学习笔记</a><time datetime="2025-05-25T02:15:29.000Z" title="Created 2025-05-25 10:15:29">2025-05-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/25/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Redis学习笔记">Redis学习笔记</a><time datetime="2025-05-25T02:14:55.000Z" title="Created 2025-05-25 10:14:55">2025-05-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/25/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Docker学习笔记">Docker学习笔记</a><time datetime="2025-05-25T02:14:27.000Z" title="Created 2025-05-25 10:14:27">2025-05-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By 李瑞康</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>